-- esp-modul

local ESP = {}
ESP.espEnabled = true
ESP.teamCheckEnabled = true
ESP.tracersEnabled = true
ESP.tracerFromBottom = false
ESP.espMaxDistance = 3000
ESP.tracerThickness = 2
ESP.boxTransparency = 0.5 -- Прозрачность бокса (оставляем, хотя не используется в интерфейсе)
ESP.boxThickness = 0.1 -- Толщина бокса (оставляем, хотя не используется в интерфейсе)
ESP.textSize = 10
ESP.espVisibleColor = Color3.fromRGB(0, 255, 0) -- Цвет для видимых игроков
ESP.espNotVisibleColor = Color3.fromRGB(255, 0, 0) -- Цвет для невидимых игроков
ESP.skeletonEnabled = false -- Настройка для Skeleton ESP
ESP.xrayEnabled = false -- Настройка для X-Ray
ESP.xrayColor = Color3.fromRGB(128, 0, 128) -- Фиолетовый цвет для X-Ray (RGB: 128, 0, 128)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- Таблица для хранения объектов ESP
local espObjects = {}

-- Функция для создания объекта Drawing
local function createDrawing(type)
    local drawing = Drawing.new(type)
    return drawing
end

-- Функция для получения позиции на экране
local function getScreenPosition(position)
    local screenPos, onScreen = Camera:WorldToViewportPoint(position)
    return Vector2.new(screenPos.X, screenPos.Y), onScreen
end

-- Функция для проверки, является ли игрок видимым
local function isPlayerVisible(player)
    local character = player.Character
    if not character then return false end

    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return false end

    local distance = (rootPart.Position - Camera.CFrame.Position).Magnitude
    local ray = Ray.new(Camera.CFrame.Position, (rootPart.Position - Camera.CFrame.Position).Unit * distance)
    local hit = workspace:FindPartOnRayWithIgnoreList(ray, {LocalPlayer.Character or {}})
    return hit == nil or hit:IsDescendantOf(character)
end

-- Основная функция обновления ESP
local function updateESP()
    for _, player in pairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if ESP.teamCheckEnabled and player.Team == LocalPlayer.Team then continue end

        local character = player.Character
        if not character then
            if espObjects[player] then
                for _, obj in pairs(espObjects[player]) do
                    obj:Remove()
                end
                espObjects[player] = nil
            end
            continue
        end

        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then continue end

        local distance = (rootPart.Position - Camera.CFrame.Position).Magnitude
        if distance > ESP.espMaxDistance then
            if espObjects[player] then
                for _, obj in pairs(espObjects[player]) do
                    obj:Remove()
                end
                espObjects[player] = nil
            end
            continue
        end

        -- Создаём объекты ESP, если их ещё нет
        if not espObjects[player] then
            espObjects[player] = {
                box = createDrawing("Quad"),
                tracer = createDrawing("Line"),
                name = createDrawing("Text"),
                skeleton = {} -- Таблица для линий скелета
            }
        end

        local esp = espObjects[player]
        local box = esp.box
        local tracer = esp.tracer
        local name = esp.name
        local skeleton = esp.skeleton

        -- Позиция на экране (центр персонажа)
        local screenPos, onScreen = getScreenPosition(rootPart.Position)
        if not onScreen then
            box.Visible = false
            tracer.Visible = false
            name.Visible = false
            for _, line in pairs(skeleton) do
                line.Visible = false
            end
            continue
        end

        -- Проверка видимости (если X-Ray выключен)
        local isVisible = true
        if not ESP.xrayEnabled then
            isVisible = isPlayerVisible(player)
        end

        -- Определяем цвет в зависимости от X-Ray
        local espColor
        if ESP.xrayEnabled then
            espColor = ESP.xrayColor -- Фиолетовый цвет для X-Ray
        else
            espColor = isVisible and ESP.espVisibleColor or ESP.espNotVisibleColor
        end

        -- Исправление бокса: используем GetBoundingBox для всей модели
        local modelCFrame, modelSize = character:GetBoundingBox()
        local halfSize = modelSize / 2
        local corners = {
            modelCFrame * CFrame.new(-halfSize.X,  halfSize.Y, 0), -- Верхний левый
            modelCFrame * CFrame.new( halfSize.X,  halfSize.Y, 0), -- Верхний правый
            modelCFrame * CFrame.new( halfSize.X, -halfSize.Y, 0), -- Нижний правый
            modelCFrame * CFrame.new(-halfSize.X, -halfSize.Y, 0)  -- Нижний левый
        }

        local screenCorners = {}
        local minX, maxX, minY, maxY
        for i, corner in ipairs(corners) do
            local screenPoint, isOnScreen = Camera:WorldToViewportPoint(corner.Position)
            screenCorners[i] = Vector2.new(screenPoint.X, screenPoint.Y)
            if i == 1 then
                minX, maxX = screenPoint.X, screenPoint.X
                minY, maxY = screenPoint.Y, screenPoint.Y
            else
                minX = math.min(minX, screenPoint.X)
                maxX = math.max(maxX, screenPoint.X)
                minY = math.min(minY, screenPoint.Y)
                maxY = math.max(maxY, screenPoint.Y)
            end
        end

        -- Рисуем бокс
        box.PointA = Vector2.new(minX, minY) -- Верхний левый
        box.PointB = Vector2.new(maxX, minY) -- Верхний правый
        box.PointC = Vector2.new(maxX, maxY) -- Нижний правый
        box.PointD = Vector2.new(minX, maxY) -- Нижний левый
        box.Color = espColor
        box.Thickness = 2 -- Используем фиксированную толщину, так как настройки удалены из интерфейса
        box.Transparency = 0 -- Используем фиксированную прозрачность, так как настройки удалены из интерфейса
        box.Visible = ESP.espEnabled

        -- Трейсер
        if ESP.tracersEnabled then
            local tracerStart = ESP.tracerFromBottom and Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y) or Vector2.new(Camera.ViewportSize.X / 2, 0)
            tracer.From = tracerStart
            tracer.To = screenPos
            tracer.Color = espColor
            tracer.Thickness = ESP.tracerThickness
            tracer.Visible = ESP.espEnabled
        else
            tracer.Visible = false
        end

        -- Имя
        name.Text = player.Name .. " [" .. math.floor(distance) .. "]"
        name.Position = Vector2.new(screenPos.X, minY - 20)
        name.Size = ESP.textSize
        name.Color = espColor
        name.Center = true
        name.Outline = true
        name.OutlineColor = Color3.fromRGB(0, 0, 0)
        name.Visible = ESP.espEnabled

        -- Skeleton ESP
        if ESP.skeletonEnabled then
            -- Определяем ключевые части тела
            local parts = {
                Head = character:FindFirstChild("Head"),
                UpperTorso = character:FindFirstChild("UpperTorso"),
                LowerTorso = character:FindFirstChild("LowerTorso"),
                LeftUpperArm = character:FindFirstChild("LeftUpperArm"),
                RightUpperArm = character:FindFirstChild("RightUpperArm"),
                LeftLowerArm = character:FindFirstChild("LeftLowerArm"),
                RightLowerArm = character:FindFirstChild("RightLowerArm"),
                LeftUpperLeg = character:FindFirstChild("LeftUpperLeg"),
                RightUpperLeg = character:FindFirstChild("RightUpperLeg"),
                LeftLowerLeg = character:FindFirstChild("LeftLowerLeg"),
                RightLowerLeg = character:FindFirstChild("RightLowerLeg")
            }

            -- Определяем связи между частями тела
            local connections = {
                {from = "Head", to = "UpperTorso"},
                {from = "UpperTorso", to = "LowerTorso"},
                {from = "UpperTorso", to = "LeftUpperArm"},
                {from = "UpperTorso", to = "RightUpperArm"},
                {from = "LeftUpperArm", to = "LeftLowerArm"},
                {from = "RightUpperArm", to = "RightLowerArm"},
                {from = "LowerTorso", to = "LeftUpperLeg"},
                {from = "LowerTorso", to = "RightUpperLeg"},
                {from = "LeftUpperLeg", to = "LeftLowerLeg"},
                {from = "RightUpperLeg", to = "RightLowerLeg"}
            }

            -- Рисуем линии скелета
            for i, connection in ipairs(connections) do
                local fromPart = parts[connection.from]
                local toPart = parts[connection.to]
                if fromPart and toPart then
                    local fromPos, fromOnScreen = getScreenPosition(fromPart.Position)
                    local toPos, toOnScreen = getScreenPosition(toPart.Position)
                    if fromOnScreen and toOnScreen then
                        if not skeleton[i] then
                            skeleton[i] = createDrawing("Line")
                        end
                        local line = skeleton[i]
                        line.From = fromPos
                        line.To = toPos
                        line.Color = espColor
                        line.Thickness = 1
                        line.Visible = ESP.espEnabled
                    else
                        if skeleton[i] then
                            skeleton[i].Visible = false
                        end
                    end
                else
                    if skeleton[i] then
                        skeleton[i].Visible = false
                    end
                end
            end
        else
            for _, line in pairs(skeleton) do
                line.Visible = false
            end
        end
    end
end

-- Запускаем обновление ESP
RunService.RenderStepped:Connect(updateESP)

-- Очистка при выходе игрока
Players.PlayerRemoving:Connect(function(player)
    if espObjects[player] then
        for _, obj in pairs(espObjects[player]) do
            obj:Remove()
        end
        espObjects[player] = nil
    end
end)

-- Очистка при респавне локального игрока
LocalPlayer.CharacterAdded:Connect(function()
    for player, objects in pairs(espObjects) do
        for _, obj in pairs(objects) do
            obj:Remove()
        end
        espObjects[player] = nil
    end
end)

return ESP
